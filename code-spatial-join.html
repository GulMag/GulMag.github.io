<!DOCTYPE html>
<html>
  <head><link rel="stylesheet" type="text/css" href="mystyle.css"></head>
  <style>
    body {
      /*background-image: url('back_stv.jpg');*/
      background-repeat: no-repeat;
      background-attachment: fixed;
      background-size: cover;
    }
    .header {
      background-color: transparent;
    }
  </style>

  <div class="header">
    <h1>Python</h1>
    <p>Resize the browser window to see the responsive effect.</p>
  </div>
      
  <!--------------------Navigation Bar--------------------->
  <div class="topnav">
      <a href="index.html">Home</a>
  </div>
  <!------------------------------------------------------->

  <div class="row">
    <!------------------- LEFT COLUMN ------------------>
    <div class="leftcolumn">
      <div class="card"> <!-- Python General-->
        <h2>Python General</h2>
        <p><dl>
            <dt>Check Version</dt>
            <dd><code>
                pandas.__version__
            </code></dd>
            <dt>Data Types</dt>
            <dd>Check variable type<code>
                print(type(variable_name))
            </code></dd>
            <dd>List. All the items in a list do not need to be of the same type. 
                Use the slicing operator [ ] to extract an item or a range of items from a list. 
                Index starts form 0 in Python.<br><code>
                a = [1, 2.2, 'python'] <br>
                print("a[2] = ", a[2]) <br>
                print(a[0:3])
            </code></dd>
            <dd><code>
                num = 34 
            </code></dd>
            <dt>Type Conversion</dt>
            <dd>Explicit Type Conversion is also called Type Casting, 
                the data types of object are converted using predefined function by user.<code>
                num_str = "456"<br>
                num_str = int(num_str)
            </code></dd>
            <dt>Path Handling pathlib</dt>
            <dd>Python 3.4 introduced a new standard library for dealing with files and paths called pathlib. 
                To use it, you just pass a path or filename into a new Path() object using forward slashes and it handles the rest.
            </dd>
            <p class="code"><pre>
                from pathlib import Path

                data_folder = Path("source_data/text_files/")
                file_to_open = data_folder / "raw_data.txt" 

                f = open(file_to_open)  
                print(f.read())
            </pre></p>
        </dl></p>
      </div>
      <div class="card"> <!-- Pandas Library-->
          <h2>Pandas Library</h2>
          <p>
            pandas aims to be the fundamental high-level building block for doing practical, real world data analysis in Python.
          </p>
          <p><a href="https://pandas.pydata.org/Pandas_Cheat_Sheet.pdf">Pandas Cheat Sheet</a></p>
          <p>
              Join tables (data frames) based on location using spatial join. When joining datasets by
              attributes we need matching keys in both tables, a spatial join requires locations, i.e. latitude and longitude.   
          </p>
          <p class="code"><pre>
              import pandas as pd
              import geopandas as gpd 

              # 1-  Listing points 
              listings = pd.read_csv(“data/.csv”)

              # 2 - convert to Geopandas Geodataframe 
              gdf_listings = gpd.GeoDataFrame(listings,
              geometry=gpd.points_from_xy(listings.longitude, listings.latitude))

              # 3 - Neighbourhoods 
              geojson_file = “data/stockholm_neighbourhoods.geojson”
          </pre></p>
          <dt>Cast a pandas object to a specified dtype</dt>
          <dd><code>
            df.astype({'col1': 'int32'}).dtypes
            df.astype('float').dtypes
          </code></dd>
          <dt>Count NaN or missing values</dt>
          <dd><code>
            gdf_acled['long'].isnull().sum()
          </code></dd>
          <dt>Drop missing values</dt>
          <dd>Drop the rows where at least one element is missing.<br>
            <code> 
              df.dropna() <br>
              df.dropna(subset=['name', 'born'])</code><br>
            Drop the columns where at least one element is missing.<br>
            <code>df.dropna(axis='columns')</code><br>
          </dd>
          <dt>Read Files</dt>
          <dd><code>
            pandas.read_csv('data.csv', )<br>
            pandas.read_excel('data.xlsx')
          </code></dd>
          <dt>Creat Test Data</dt>
          <dd><code>
            df_test = df_acled.head(n=50)
          </code></dd>
          <dt>Pandas Filter</dt>
          <dd>A data frames columns can be queried with a boolean expression. 
            Every frame has the module query() as one of its objects members<br>
            <code>
              gdf_scad_filtered = gdf_scad.query('styr==2003')<br>
              gdf_acled_buffer_filtered = gdf_acled_buffer[gdf_acled_buffer.year==2003.0]<br>
              # select columns by name<br>
              df.filter(items=['c1', 'c5'])
            </code>
          </dd>
          <dt>DataFrame.rename</dt>
          <dd><code>df.rename(columns={"A": "a", "B": "c"})</code></dd>
          <dt>Indexing and Selecting Data</dt>
          <dd>
            <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy", target="_blank">Linke to Pandas Documentation</a>
          </dd>
          <dt>Size</dt>
          <dd>
            <code>
              s = pd.Series({'a': 1, 'b': 2, 'c': 3})<br>
              s.size<br>
              df = pd.DataFrame({'col1': [1, 2], 'col2': [3, 4]})<br>
              df.size
            </code>
          </dd>
          <dt>Join Tables</dt>
          <dd>
            <code>pd.concat(objs, axis=0, join='outer', ignore_index=False, keys=None,
              levels=None, names=None, verify_integrity=False, copy=True)<br>
              result = pd.concat([df1, df4], axis=1, join='inner')</code>
          </dd>
      </div>
      <div class="card"> <!-- Geopandas -->
        <h2>Geopandas</h2>
        <p><dl>
            <dt>Installation with Anaconda</dt>
            <dd>The conda package manager provides pre-built binaries for all required and 
              optional dependencies of GeoPandas for all platforms (Windows, Mac, Linux).
              <code>
              conda install geopandas <br>
              import panda as pd <br>
              import geopanda as gpd <br>
              </code>
            </dd>
            <dt>Read Spatial Data</dt>
            <dd>geopandas can read almost any vector-based spatial data format including 
              ESRI shapefile, GeoJSON files and more
              <code>
              geopandas.read_file() <br>
              pandas.read_csv() 
              </code>
            </dd>
            <dt>Managing Projections</dt>
            <dd>
              <code>
              my_geoseries.crs
              my_geoseries = my_geoseries.to_crs("EPSG:3395")
              </code>
            </dd>
            <dt>Spatial Join</dt>
            <dd>
              <code>
                sjoin(df1, df2, op="", how="")
              </code>
            </dd>
        </dl></p>
      </div>
      <div class="card"> <!-- Matplotlib--->
        <h2><code>matplotlib</code></h2>
        <p>
            Matplotlib graphs your data on Figures (i.e., windows, Jupyter widgets, etc.), each of which can contain one or more Axes 
            (i.e., an area where points can be specified in terms of x-y coordinates (or theta-r in a polar plot, or x-y-z in a 3D plot, etc.). 
            The most simple way of creating a figure with an axes is using pyplot.subplots. 
            We can then use Axes.plot to draw some data on the axes:
        </p>
        <p class = "code">
            fig = plt.figure()  # an empty figure with no Axes <br>
            fig, ax = plt.subplots()  # Create a figure containing a single axes. <br>
            ax.plot([1, 2, 3, 4], [1, 4, 2, 3])  # Plot some data on the axes. 
        </p>
      </div>
      <div class="card"> <!-- Matplotlib--->
        <h2><code>recordlinkage</code></h2>
        <p>
          One of the challenges in merging administrative datasets is that different datasets will often include records 
          about the same entity (e.g., the same individual), but matching between these records and merging across disparate datasets, 
          or even identifying linked records within the same dataset, can be challenging. This is because often the data may not include 
          sufficient information to unambiguously identify individuals. Even when unambiguous data (i.e., uniquely idenfitying data, 
          such as full name and date of birth) is recorded, often the records can contain small errors in the way in which the 
          identity of the entity is stored, making automated linkage difficult.
        </p>
        <dl>
          <dt>Installation</dt>
          <dd><code>
            !pip install recordlinkage <br>
            import recordlinkage
          </code></dd>
          <dt>Indexing/ Blocking</dt>
          <dd>
            A full index is an index with all possible combinations of record pairs. In case of linking, this indexation method generates the cartesian product of both DataFrame’s.  
            Block() Returns all record pairs that agree on the given variable(s). This method is known as blocking. Blocking is an effective way to make a subset of the record space (A * B). 
            The indexing module is used to make pairs of records. Comparing all record can be computationally intensive.
            Therefore, we make a smart set of socalled candidate links or candidate matches. 
            There are several indexing algorithms available such as blocking (e.g.Only records pairs that agree on the surname are included. ) and sorted neighborhood indexing.
            Only records pairs that agree on the surname are included. <br>
            In my case i think blocking could make sense on the date
            <code>
              index = recordlinkage.Index(df_a, df_b)<br>
              candidate_links = index.block('surname')
            </code>
          </dd>
          <dt>Compare</dt>
          <dd>
            The recordlinkage.Compare class and its methods can be used to compare records pairs. 
            Several comparison methods are included such as string similarity measures, numerical 
            measures and distance measures. <br>
            <code><pre>

              # initialise class 
              comp = recordlinkage.Compare()

              # initialise similarity measurement algorithms
              comp.string('first_name', 'name', method='jarowinkler')
              comp.string('lastname', 'lastname', method='jarowinkler')
              comp.exact('dateofbirth', 'dob')
              comp.exact('sex', 'sex')
              comp.string('address', 'address', method='levenshtein')
              comp.exact('place', 'place')
              comp.numeric('income', 'income')

              # the method .compute() returns the DataFrame with the feature vectors.
              comp.compute(candidate_pairs, census_data_1980, census_data_1990)
              
            </pre></code>
          </dd>
        </dl>
        <p class = "code">
            fig = plt.figure()  # an empty figure with no Axes
            fig, ax = plt.subplots()  # Create a figure containing a single axes. <br>
            ax.plot([1, 2, 3, 4], [1, 4, 2, 3])  # Plot some data on the axes.
        </p>
      </div>
    </div>
    <!------------------- RIGHT COLUMN ------------------>
    <div class="rightcolumn">
      <div class="card" background-color: none>
        <h2>Navigation</h2>
        <div class = "btn-group">
          <a href="code-string-matching.html"><button class="button">String Matching</button></a>
          <a href="code-spatial-join.html"><button class="button">Spatial Join Python</button></a>
          <a href="code-quick-r.html"><button class="button">Quick R</button></a>
          <a href="code-nlp.html"><button class="button">NLP</button></a>
          <a href="code-gradient-boosted-trees.html"><button class="button">Gradient Boosted Trees</button></a>
          <a href="code-xgboost-r.html"><button class="button">XGBoost in R</button></a>
        </div>
      </div>
    </div>
    <!-------------------- END COLUMN ------------------->
  </div>
</html>